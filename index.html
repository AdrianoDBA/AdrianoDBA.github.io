<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Previsões Solana (SOL)</title>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.0.0/dist/simple-statistics.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/arima"></script>
</head>
<body>
    <h1>Previsões de Preços da Solana (SOL)</h1>
    <p>Veja abaixo as previsões utilizando os modelos Holt-Winters e ARIMA para os dados históricos de preços da Solana.</p>

    <div>
        <h2>Preço Atual:</h2>
        <p id="preco-atual">Carregando...</p>
    </div>

    <div>
        <h2>Volatilidade:</h2>
        <p id="volatilidade">Carregando...</p>
    </div>

    <div>
        <h2>Tendência:</h2>
        <p id="tendencia">Carregando...</p>
    </div>

    <div>
        <h3>Previsões SARIMA (7 dias):</h3>
        <pre id="resultadoARIMA"></pre>
    </div>
    
    <div>
        <h3>Previsões Holt-Winters (7 dias):</h3>
        <pre id="resultadoHW"></pre>
    </div>

    <script>
        // Função para obter os dados históricos da Solana (SOL) usando a API Coingecko
        async function obterDadosSolana() {
            try {
                const resposta = await axios.get('https://api.coingecko.com/api/v3/coins/solana/market_chart', {
                    params: {
                        vs_currency: 'usd',
                        days: '365',  // Obtendo os últimos 365 dias
                    }
                });

                // Extraindo os preços diários
                const dados = resposta.data.prices.map(preco => preco[1]);

                // Exibir o preço atual
                document.getElementById('preco-atual').textContent = resposta.data.prices[resposta.data.prices.length - 1][1];

                // Calcular a volatilidade
                const volatilidade = calcularVolatilidade(dados);
                document.getElementById('volatilidade').textContent = volatilidade.toFixed(2);

                // Determinar a tendência
                const tendencia = calcularTendencia(dados);
                document.getElementById('tendencia').textContent = tendencia;

                // Realizando previsões
                realizarPrevisoes(dados);
            } catch (erro) {
                console.error("Erro ao obter dados da Solana:", erro);
            }
        }

        // Função para calcular a volatilidade
        function calcularVolatilidade(dados) {
            const desvios = simpleStatistics.standardDeviation(dados);
            return desvios;
        }

        // Função para determinar a tendência
        function calcularTendencia(dados) {
            const diferencas = [];
            for (let i = 1; i < dados.length; i++) {
                diferencas.push(dados[i] - dados[i - 1]);
            }

            const somaDiferencas = diferencas.reduce((a, b) => a + b, 0);
            const mediaDiferencas = somaDiferencas / diferencas.length;

            if (mediaDiferencas > 0) {
                return "Positiva";
            } else if (mediaDiferencas < 0) {
                return "Negativa";
            } else {
                return "Neutra";
            }
        }

        // Função Holt-Winters
        function holtWinters(data, alpha, beta, gamma, period) {
            let level = data[0];
            let trend = data[1] - data[0];
            let seasonal = [];

            for (let i = 0; i < period; i++) {
                seasonal.push(data[i] / level);
            }

            let forecast = [];
            for (let t = period; t < data.length + period; t++) {
                level = alpha * (data[t] / seasonal[t % period]) + (1 - alpha) * (level + trend);
                trend = beta * (level - seasonal[t % period]) + (1 - beta) * trend;
                seasonal[t % period] = gamma * (data[t] / level) + (1 - gamma) * seasonal[t % period];

                forecast.push(level + trend * (t - (data.length - period)));
            }

            return forecast;
        }

        // Função ARIMA
        function realizarARIMA(dados) {
            const model = new ARIMA({
                p: 1,  // Ordem AR
                d: 1,  // Diferenciação
                q: 1   // Ordem MA
            });

            model.train(dados);
            let previsaoARIMA = model.predict(7); // Previsões para os próximos 7 dias
            return previsaoARIMA;
        }

        // Função para realizar as previsões Holt-Winters e ARIMA
        function realizarPrevisoes(dados) {
            // Holt-Winters
            let alpha = 0.5;
            let beta = 0.1;
            let gamma = 0.1;
            let period = 7;  // Sazonalidade semanal (7 dias)

            let resultadoHW = holtWinters(dados, alpha, beta, gamma, period);
            document.getElementById('resultadoHW').textContent = resultadoHW.map((valor, i) => `Dia ${i+1}: ${valor.toFixed(2)}`).join("\n");

            // ARIMA
            let resultadoARIMA = realizarARIMA(dados);
            document.getElementById('resultadoARIMA').textContent = resultadoARIMA.map((valor, i) => `Dia ${i+1}: ${valor.toFixed(2)}`).join("\n");
        }

        // Chamar a função para obter os dados e gerar as previsões
        obterDadosSolana();
    </script>
</body>
</html>
